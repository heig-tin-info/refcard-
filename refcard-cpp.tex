\documentclass{article}

\usepackage[a4paper, landscape, margin=1cm]{geometry}
\usepackage{fontspec}
\usepackage[french]{babel}
\usepackage[fontsize=6.5pt]{scrextend}
\usepackage[T1]{fontenc}
\usepackage{multicol}
\usepackage{tabularx}
\usepackage{sectsty}
\usepackage{lmodern}
\usepackage{stix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{titlesec}

\input{revision}

\setlength{\parskip}{0.2em}
\setlength{\parindent}{0em}

% Highlight configuration for C programming language
\lstset{
  language=c,
  breaklines=true,
  keywordstyle=\bfseries\color{black},
  basicstyle=\ttfamily\color{black},
  emphstyle={\em \color{gray}},
  emph={expr, type, NAME, ptr, name, expr, value, filename, label, member, type},
  mathescape=true,
  keepspaces=true,
  showspaces=false,
  showtabs=true,
  tabsize=3,
  upquote=true,
  columns=fullflexible,
  aboveskip=0.5ex,belowskip=0.5ex,
  escapeinside={(*}{*)}
}

% Configuration
\renewcommand{\familydefault}{\sfdefault}

% Titles and paragraphs more compact
\sectionfont{\fontsize{12}{15}\selectfont}
\subsectionfont{\fontsize{10}{12}\selectfont}
\subsubsectionfont{\fontsize{7}{9}\selectfont}

\allsectionsfont{\sffamily\underline}

% No pages numbering
\pagenumbering{gobble}

% Titles and paragraphs more compact
\titlespacing*{\section}{0pt}{0ex}{0ex}
\titlespacing*{\subsection}{0pt}{0ex}{0ex}
\titlespacing*{\subsubsection}{0pt}{0ex}{0ex}

\newlength\mybaselinestretch
\mybaselinestretch=0pt plus 0.02pt\relax
\addtolength{\baselineskip}{\mybaselinestretch}

\setlength\parindent{0pt}
\setlength\tabcolsep{1.5pt}
\setlength{\columnseprule}{0.4pt}

% Macros
\newcommand{\tab}{\hspace{2em}}
\newcommand{\etc}{\small \ldots}
\newcommand{\any}{$\hzigzag$~}
\newcommand{\spc}{$\mathvisiblespace$}
\newcommand{\cd}{\lstinline}

\begin{document}

\begin{multicols*}{3}

\begin{center}
  {\Large \bf Carte de référence C++11/C++17} \\
  HEIG-VD -- version \revision \ -- \revisiondate \\
\end{center}

Cette carte de référence peut être utilisée durant les travaux écrits et examens
des cours \emph{progoo} et \emph{progoox} à moins que le contraire ne soit explicitement formulé.

Ce travail est inspiré de \emph{Learn X in Y} et de la carte de référence de Matt Mahoney.

Signification des termes utilisés dans cette carte de référence.

\begin{tabularx}{\linewidth}{
  >{\hsize=0.5\hsize}X% 10% of 4\hsize
  >{\hsize=1.5\hsize}X% 30% of 4\hsize
  >{\hsize=0.5\hsize}X% 30% of 4\hsize
  >{\hsize=1.5\hsize}X% 30% of 4\hsize
     % sum=4.0\hsize for 4 columns
  }

  \tt \etc      & Continuation logique    & \tt \any    & N'importe quoi d'accepté \\
  \tt /\any/    & Expression régulière    & \tt \spc    & Espace obligatoire \\
  \cd{type}     & \tt int, long, float, ... & \cd{name} & \tt /[A-Za-z][A-Za-z0-9\_]+/ \\
  \cd{value}    & Valeur & \cd{NAME} & \tt /[A-Z][A-Z0-9\_]+/ \\
  \cd{filename} & Chemin de fichier relatif & \cd{expr}   & e.g. \tt a + b \\
\end{tabularx}
\hrule

\section*{Différences C/C++}
\begin{lstlisting}
sizeof('c') == sizeof(char) == 1 // Différence par rapport au C
void func();                     // func n'accepte aucun arguments
int *ip = nullptr;               // Utiliser à la place de NULL
#include <cstdio>                // Remplace <stdio.h> (pas de .h)
int& r = x;                      // Référence r sur x
using Alias=long int;            // Substitut à typedef
for (auto x; iterable);          // Boucle itérative sur itérable
\end{lstlisting}

\section*{Entrées sorties}

\begin{lstlisting}
#include <iostream>
using namespace std; // Les streams dans l'espace de nom std
int main() {
   int i;
   cout << "Enter your favorite number:\n");
   cin >> i; // Lecture de i sur l'entrée standard
   cout << "Your favorite number is " << i << "\n";
   cerr << "An error message" << endl;
   clog << "Standard logging stream, équivalent à cerr\n"
}
\end{lstlisting}

\section*{Chaînes de caractère}

\begin{lstlisting}
#include <string>
string a = "Hello", b = "World";
cout << a + b;                    // "Hello World"
cout << a + " You";               // "Hello You"
a.append(" Dog");                 // En C++ les chaînes sont modifiables
cout << a;                        // "Hello Dog"

// Buffer de string
std::stringstream ss;
ss << 100 << ' ' << 200 << ' ' << 300;
int foo, bar;
ss >> foo >> bar;                 // Lecture de 100 et 200
std::string s = ss.str();         // Conversion en string
s._cstr();                        // Conversion en char *

// Manipulateurs (foo = 100)
#include <iomanip>
cout << "Dec = " << setbase(10) << foo << endl; // 100
cout << "Hex = " << setbase(16) << foo << endl; // 64
cout << setw(5) << foo << endl;        // Affiche "  100"
cout << setfill('x') << foo << endl;   // Affiche "xx100"
cout << setprecision(5) << pi << endl; // "3.1416"
\end{lstlisting}

\section*{Surcharge paramétrique}

\begin{lstlisting}
void say(char const* s) { printf("%s\n", s); }
void say(int u) { printf("%d\n", u); }
void main() { say("Hello"); say(15); }

// Arguments par défaut
void foo(int a = 1; int b = 4) { ... }
void main() { foo(); /* a=1, b=4 */ foo(20); /* a=20, b=4 */
              foo(20, 5); /* a=20, b=5 */ }
\end{lstlisting}

\section*{Références}

\begin{lstlisting}
string foo = "I am foo";
string& fooRef = foo;       // Référence sur foo
fooRef += ". Hi!";          // Modifie foo via la référence
cout << fooRef;             // Affiche "I am foo. Hi!"

cout << &fooRef << endl;    // Affiche l'adresse de foo
string bar = "I am bar";
fooRef = bar;
cout << &fooRef << endl;    // Affiche toujours l'adresse de foo
cout << fooRef;             // Affiche "I am bar"

const string& barRef = bar;
barRef += ". Hi!";          // Erreur !

// Objets temporaires
string foo() { ... }
string retVal = foo(); // Valeur de retour est temporaire

void bar() {
  const string& constRef = foo();
  // Référence valide jusqu'à la fin de la fonction
}

string str;
void func(string& s) { ... }  // Référence standard
void func(string&& s) { ... } // Référence temporaire (move semantics)
func(str);                    // Référence standard
func(foo());                  // Référence temporaire

\end{lstlisting}

\section*{Enumérations}

\begin{lstlisting}
enum AnimalTypes { // Enumération style C, plain enum (à éviter)
    Mammals, Birds, Reptiles, Amphibians, Fish // Mammals == 0
};

AnimalTypes GetAnimalType() { // S'utilise comme un type
    return AnimalTypes::REPTILES;
}

// Les valeurs seront 0,1,42,43, peut être implicitement casté en uint8_t
enum Amphibians : uint8_t { Frogs, Newts, Salamanders=42, Toads};

// Méthode privilégiée pour enum : ne sera pas implicitement casté
enum class Birds : uint8_t { Chickens, Hummingbirds };
\end{lstlisting}

\section*{Templates}
Type de polymorphisme paramétrique statique (à la compilation)
\begin{lstlisting}
template<typename T>
struct Box { void insert(const T&) { ... } };
Box<int> intBox; intBox.insert(42);

Box<Box<int> > boxOfBox;  // Template imbriquées (espace après >)
boxOfBox.insert(intBox);

template <typename T> T f(T t);
template <typename T> class X { X(T t); }; // Classe avec paramètre T
template <typename T> X<T>::X(T t) {}      // Définition du constructeur
X<int> x(3);                               // Un objet de type X de int
template <typename T, class U=T, int n=0>  // Paramètres par défaults

// Une template peut aussi prendre des paramètres scalaires.
template<int Y> void printMessage() { cout << "You want " << Y << endl; }

// Spécialisation : crée un cas particulier pour la valeur 42.
template<> void printMessage<42>() { cout << "You said 42!" << endl; }
printMessage<23>(); // Your number is 23
printMessage<42>(); // You said 42!

\end{lstlisting}

\section*{Namespaces}

\begin{lstlisting}
extern "C" { void f(); }    // Si f() a été compilé dans un objet C
namespace N { class T {}; } // Cache la classe T dans le namespace N
N::T t;                     // Utilise le nom T du namespace N
using namespace N;          // Rends T visible sans le préfix 'N::'
using namespace std;        // Permet les appels standards sans 'std::'

namespace First {
    namespace Nested {
        void foo() { printf("This is First::Nested::foo\n"); }
    }
}
namespace Second {
    void foo() { printf("This is Second::foo\n"); }
}
void foo() {
    printf("This is global foo\n");
}

int main() {
    using namespace Second;    // Intègre Second au contexte local
    Second::foo();
    First::Nested::foo();
    ::foo();                   // Global foo
    foo();                     // Erreur car ambïgu
}
\end{lstlisting}

\section*{Classes}

\begin{lstlisting}
// Généralement déclaré dans un .h (ou .hpp)
class Dog {
    std::string name;     // Privé par défaut (private:)
    int weight;
  public:                 // Accès possible par tous
    Dog();                // Constructeur par défaut
    Dog(Dog &other);      // Constructeur par copie

    void setName(const std::string& dogsName);
    void setWeight(int dogsWeight);

    // Si marqué const, la méthode ne modifie pas l'état de l'objet.
    virtual void print() const;

    // Méthode implémentée dans le body d'une classe
    void bark() const { std::cout << name << " barks!" << endl; }

    // Déstructeur doit être virtuel si peut être dérivé
    virtual ~Dog();

  protected:               // Accès possible par les classes dérivées
  private:                 // Accès impossible aux classes dérivées
};                         // Ne pas oublier le point virgule !

// Déclarations implémentées dans un .cpp avec le préfix du namespace
Dog::Dog() { cout << "Nouveau chien construit\n"; }
Dog::~Dog() { cout << "Adieu " << name << "\n"; }

int main() {
    Dog myDog; // Affiche "Nouveau chien construit"
    myDog.setName("Barkley");
    myDog.setWeight(10);
} // Affiche "Adieu Barkley"

class C { // Classe abstraite
    virtual void foo;                      // Méthode virtuelle
    virtual bar = 0;                       // Méthode virtuelle pure
    C() = default;                         // Valeur par défaut
    const C& operator=(C &other) = delete; // Affectation supprimée
};
\end{lstlisting}

\section*{Héritage et polymorphisme}

\begin{lstlisting}
class OwnedDog : public Dog {
public:
    void setOwner(const std::string& dogsOwner);
    void print() const override; // Surcharge
private:
    std::string owner;
};

void OwnedDog::print() const {
    Dog::print(); // Appel de la méthode du parent
    std::cout << "Dog is owned by " << owner << endl;
}
\end{lstlisting}

\section*{Polymorphisme}

\begin{lstlisting}
T operator+(T x, T y);  // Surcharge opérateur addition de type T
T operator-(T x);       // Surcharge opérateur unaire de negation -x
T operator++(int);      // Surcharge opérateur postfix

\end{lstlisting}

\section*{Exceptions}

\begin{lstlisting}
#include <exception>
#include <stdexcept>

try {
   throw std::runtime_error("A problem occured");
}
catch (const std::exception& ex) {
   std::count << ex.what();
}
catch (...) {
   std::cout << "Unknown exception caught";
   throw; // Relève l'exception
}
\end{lstlisting}

\section*{STL}

\subsection*{Conteneurs de données séquentiels}

\begin{lstlisting}
array // Tableau statique contigus
vector // Tableau dynamique O(1) amorti à l'insertion
deque // Queue double (double-ended queue)
forward_list // Liste chaînée simple
list // Liste chaînée double
\end{lstlisting}

\subsection*{Vector}

\begin{lstlisting}
#include <vector>

string val;
vector<string> vect;
cin >> val;
vect.push_back(val); // Ajoute à la fin
vect.pop_back(val);  // Enlève à la fin
vect.insert(iterator position, const value_type &val);
vect.erase(iterator position); // Efface une position
vect.erase(iterator first, iterator last); // Efface un intervalle
vect[i]; // Position i
vect.front(); vect.back() // Accès des extrémités
vect.empty(); // Vide ?
vect.capacity(); // Taille du vecteur

\end{lstlisting}

\subsection*{Tuples}

\begin{lstlisting}
#include <tuple>

auto x = make_tuple(10, 'A');
const int maxN = 1e9;
const int maxL = 15;
auto y = make_tuple(maxN, maxL);

// Affichage
cout << get<0>(x) << " " << get<1>(x) << "\n"; // Affiche "10 A"
cout << get<0>(y) << " " << get<1>(y) << "\n"; // Affiche "1000000000 15"

// Unpacking
int i;
int c;
tie(i, c) = x;

tuple<int, char, double> z(11, 'A', 3.1415);

cout << tuple_size<decltype(z)>::value << "\n"; // Affiche 3

auto concatenated = tuple_cat(x, y, z); // (10, 'A', 1e9, 15, 11, 'A', 3.1415)

\end{lstlisting}

\subsection*{Map}

\begin{lstlisting}
#include <map>

map<char, int> mymap;
mymap.insert(pair<char,int>('A', 1));
mymap.insert(pair<char,int>('Z', 26));
map<char,int>::iterator it;

// Affiche A->1, Z->26
for (it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << "->" << it->second << ', ';

it = mymap.find('Z');
count << it->second; // Affiche 26

#include <unordered_map> // Plus performant mais ordre non préservé

\end{lstlisting}

\subsection*{Set}

\begin{lstlisting}
#include <set>

set<int> ST;

ST.insert(4);
ST.insert(8);
ST.insert(15);

ST.erase(8);

set<int>::iterator it;
for(it=ST.begin();it<ST.end();it++) {
    cout << *it << endl;
}

ST.clear();
cout << ST.size(); // Affiche zéro

\end{lstlisting}

\section*{Fonctions anonymes (lambda)}

\begin{lstlisting}
vector<pair<int, int> > tester;
tester.push_back(make_pair(3,6));
tester.push_back(make_pair(1,9));
tester.push_back(make_pair(5,0));
sort(
    tester.begin(),
    tester.end(),
    [](const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second < rhs.second;
    }
);

struct S { void f(int i); };
void S::f(int i) {
    [&, i]{};      // Ok
    [&, &i]{};     // Erreur : i précédé par & quand & est le défaut
    [=, this]{};   // Erreur : this quand = est défaut
    [=, *this]{};  // OK
    [i, i]{};      // Erreur : i répété

    [&]{};         // Capture le contexte parent par référence
    [=]{};         // Capture le contexte parent par copie
    [ ]{};         // Ne capture pas le contexte parent
}

\end{lstlisting}

\subsection*{Itérateurs}

\begin{lstlisting}
for (auto x; iterable);   // Boucle itérative sur itérable

vector<int>::iterator ptr; // Itérable explicite
for (ptr=ar.begin(); ptr < ar.end(); ptr++);

\end{lstlisting}


\section*{Tokens alternatifs}

\begin{lstlisting}
true and false  // Conjonction logique (&&)
true or false   // Disjonction logique (||)
not true        // Négation logique (!)
compl 4         // Complément à 1 (~)
4 bitor 3       // Disjonction bit à bit (|)
4 bitand 3      // Conjonction bit à bit (&)
4 xor 3         // Disjonction exclusive bit à bit (^)
\end{lstlisting}

\section*{Smart Pointer}

Contruction RAII, pas besoin d'appeler \emph{delete}.

\begin{lstlisting}
// Pointeur unique
std::unique_ptr<Foo> foo = std::make_unique<Foo>(Foo);
std::unique_ptr<Foo> bar = nullptr;
bar = std::move(foo);

// Pointeur multiple (shared_ptr)
auto dog = std::make_shared<Dog>(Dog);
dog->bark();

// Pointeur faible
std::weak_ptr<int> gw;
gw = dog;
std::cout << gw.use_count() // 1

\end{lstlisting}

\section*{Étrangetés}

\begin{lstlisting}
// Surcharge de méthode privées est possible
class Foo {
private:
   virtual void bar();
};
class FooSub : public Foo {
   virtual void bar(); // Surcharge Foo::bar!
};

// Most Vexing parse : n'affiche rien
struct A {};
struct B { B(A a) { std::cout << "yop"; } };
int main() { B b(A()); }


// La plupart du temps
assert(0 == false and false == null);
\end{lstlisting}

\section*{S.O.L.I.D.}
\begin{description}
\item[S] Single responsibility principle
\item[O] Open for extension, closed for modification
\item[L] Liskov substition principle
\item[I] Interface segregation principle
\item[D] Dependency inversion principle
\end{description}

\end{multicols*}
\end{document}
